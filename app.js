"use strict";
//досмотрел у другой группы до 5-го занятия, поэтому чуть поэксперементировал
function calcCtoF() {
    let val_tempC = +document.getElementById('tempC').value;
    let val_tempF = val_tempC * 9 / 5 + 32;
    document.getElementById('tempF').value = val_tempF.toFixed(1);
}
function calcCtoC() {
    let val_tempF = +document.getElementById('tempF').value;
    let val_tempC = (val_tempF - 32) * 5 / 9;
    document.getElementById('tempC').value = val_tempC.toFixed(1);
}
// Дальше решил не выпендриваться
let my_name;
let admin;
my_name = "Василий";
admin = my_name;
console.log(admin);

/* тут должно примениться неявное приведение числа 20 
(10 + 10 сложатся нормально) к тексту с последующей конкатенацией
с посленей текстовой десяткой - "10". В результате "2010" */
console.log(10 + 10 + "10");
//Я знал!

/* тут должно примениться неявное приведение первого числа 10 
к тексту с последующей конкатенацией к тексту "10", в итоге "1010"
конкатерируется с неявноприведенной последней 10кой. Итог "101010"*/
console.log(10 + "10" + 10);

/*Тут сработает унарный + в итоге все сложится, как числа, ответ 30*/
console.log(10 + 10 + +"10");

/*Тут сработает унарный -, в итоге -"" превратится в -0, поделив на который
получим -infinity*/

console.log(10 / -"");

/*Тут сработает унарный +, в итоге +"2,5" превратится NaN т.к. "," 
в отличии от "." воспринимается, как текстовый символ. Поделив 10 на
NaN получим NaN, т.к. NaN, куда его в месте с числами не пихай,
всегда получим NaN, кроме проверки isNan*/

console.log(10 / +"2,5");


